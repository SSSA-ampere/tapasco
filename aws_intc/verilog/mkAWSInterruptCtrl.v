//
// Generated by Bluespec Compiler, version 2017.07.A (build 1da80f1, 2017-07-21)
//
// On Sun May  5 14:38:33 CEST 2019
//
//
// Ports:
// Name                         I/O  size props
// S_AXI_arready                  O     1 reg
// S_AXI_rvalid                   O     1 reg
// S_AXI_rdata                    O    24 reg
// S_AXI_rresp                    O     2 reg
// S_AXI_awready                  O     1
// S_AXI_wready                   O     1
// S_AXI_bvalid                   O     1 reg
// S_AXI_bresp                    O     2 reg
// irq_req                        O     3 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// S_AXI_arvalid                  I     1
// S_AXI_araddr                   I    16 reg
// S_AXI_arprot                   I     3 reg
// S_AXI_rready                   I     1
// S_AXI_awvalid                  I     1
// S_AXI_awaddr                   I    16 reg
// S_AXI_awprot                   I     3 reg
// S_AXI_wvalid                   I     1
// S_AXI_wdata                    I    24 reg
// S_AXI_wstrb                    I     3 reg
// S_AXI_bready                   I     1
// m_intr_intr                    I   128 unused
// m_ack_ack                      I    16 unused
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkAWSInterruptCtrl(CLK,
			  RST_N,

			  S_AXI_arready,

			  S_AXI_arvalid,

			  S_AXI_araddr,
			  S_AXI_arprot,

			  S_AXI_rvalid,

			  S_AXI_rready,

			  S_AXI_rdata,

			  S_AXI_rresp,

			  S_AXI_awready,

			  S_AXI_awvalid,

			  S_AXI_awaddr,
			  S_AXI_awprot,

			  S_AXI_wready,

			  S_AXI_wvalid,

			  S_AXI_wdata,
			  S_AXI_wstrb,

			  S_AXI_bvalid,

			  S_AXI_bready,

			  S_AXI_bresp,

			  m_intr_intr,

			  irq_req,

			  m_ack_ack);
  input  CLK;
  input  RST_N;

  // value method rd_fab_arready
  output S_AXI_arready;

  // action method rd_fab_m_arvalid
  input  S_AXI_arvalid;

  // action method rd_fab_m_archan
  input  [15 : 0] S_AXI_araddr;
  input  [2 : 0] S_AXI_arprot;

  // value method rd_fab_rvalid
  output S_AXI_rvalid;

  // action method rd_fab_m_rready
  input  S_AXI_rready;

  // value method rd_fab_rdata
  output [23 : 0] S_AXI_rdata;

  // value method rd_fab_rresp
  output [1 : 0] S_AXI_rresp;

  // value method wr_fab_awready
  output S_AXI_awready;

  // action method wr_fab_m_awvalid
  input  S_AXI_awvalid;

  // action method wr_fab_m_awchan
  input  [15 : 0] S_AXI_awaddr;
  input  [2 : 0] S_AXI_awprot;

  // value method wr_fab_wready
  output S_AXI_wready;

  // action method wr_fab_m_wvalid
  input  S_AXI_wvalid;

  // action method wr_fab_m_wchan
  input  [23 : 0] S_AXI_wdata;
  input  [2 : 0] S_AXI_wstrb;

  // value method wr_fab_bvalid
  output S_AXI_bvalid;

  // action method wr_fab_m_bready
  input  S_AXI_bready;

  // value method wr_fab_bresp
  output [1 : 0] S_AXI_bresp;

  // action method m_intr
  input  [127 : 0] m_intr_intr;

  // value method irq_req
  output [2 : 0] irq_req;

  // action method m_ack
  input  [15 : 0] m_ack_ack;

  // signals for module outputs
  wire [23 : 0] S_AXI_rdata;
  wire [2 : 0] irq_req;
  wire [1 : 0] S_AXI_bresp, S_AXI_rresp;
  wire S_AXI_arready, S_AXI_awready, S_AXI_bvalid, S_AXI_rvalid, S_AXI_wready;

  // inlined wires
  wire [18 : 0] rd_addr_read_data$wget;

  // ports of submodule rd_req_fifo
  wire [18 : 0] rd_req_fifo$D_IN;
  wire rd_req_fifo$CLR,
       rd_req_fifo$DEQ,
       rd_req_fifo$EMPTY_N,
       rd_req_fifo$ENQ,
       rd_req_fifo$FULL_N;

  // ports of submodule rd_resp_fifo
  wire [25 : 0] rd_resp_fifo$D_IN, rd_resp_fifo$D_OUT;
  wire rd_resp_fifo$CLR,
       rd_resp_fifo$DEQ,
       rd_resp_fifo$EMPTY_N,
       rd_resp_fifo$ENQ,
       rd_resp_fifo$FULL_N;

  // ports of submodule wr_addr_buffer
  wire [15 : 0] wr_addr_buffer$D_IN, wr_addr_buffer$D_OUT;
  wire wr_addr_buffer$CLR,
       wr_addr_buffer$DEQ,
       wr_addr_buffer$EMPTY_N,
       wr_addr_buffer$ENQ,
       wr_addr_buffer$FULL_N;

  // ports of submodule wr_data_buffer
  wire [23 : 0] wr_data_buffer$D_IN, wr_data_buffer$D_OUT;
  wire wr_data_buffer$CLR,
       wr_data_buffer$DEQ,
       wr_data_buffer$EMPTY_N,
       wr_data_buffer$ENQ,
       wr_data_buffer$FULL_N;

  // ports of submodule wr_prot_buffer
  wire [2 : 0] wr_prot_buffer$D_IN, wr_prot_buffer$D_OUT;
  wire wr_prot_buffer$CLR,
       wr_prot_buffer$DEQ,
       wr_prot_buffer$EMPTY_N,
       wr_prot_buffer$ENQ,
       wr_prot_buffer$FULL_N;

  // ports of submodule wr_strb_buffer
  wire [2 : 0] wr_strb_buffer$D_IN, wr_strb_buffer$D_OUT;
  wire wr_strb_buffer$CLR,
       wr_strb_buffer$DEQ,
       wr_strb_buffer$EMPTY_N,
       wr_strb_buffer$ENQ,
       wr_strb_buffer$FULL_N;

  // ports of submodule wr_write_fifo
  wire [45 : 0] wr_write_fifo$D_IN, wr_write_fifo$D_OUT;
  wire wr_write_fifo$CLR,
       wr_write_fifo$DEQ,
       wr_write_fifo$EMPTY_N,
       wr_write_fifo$ENQ,
       wr_write_fifo$FULL_N;

  // ports of submodule wr_write_resp_fifo
  wire [1 : 0] wr_write_resp_fifo$D_IN, wr_write_resp_fifo$D_OUT;
  wire wr_write_resp_fifo$CLR,
       wr_write_resp_fifo$DEQ,
       wr_write_resp_fifo$EMPTY_N,
       wr_write_resp_fifo$ENQ,
       wr_write_resp_fifo$FULL_N;

  // remaining internal signals
  wire [15 : 0] addr__h2155;
  wire wr_addr_buffer_i_notEmpty__4_AND_wr_prot_buffe_ETC___d60;

  // value method rd_fab_arready
  assign S_AXI_arready = rd_req_fifo$FULL_N ;

  // value method rd_fab_rvalid
  assign S_AXI_rvalid = rd_resp_fifo$EMPTY_N ;

  // value method rd_fab_rdata
  assign S_AXI_rdata = rd_resp_fifo$D_OUT[25:2] ;

  // value method rd_fab_rresp
  assign S_AXI_rresp = rd_resp_fifo$D_OUT[1:0] ;

  // value method wr_fab_awready
  assign S_AXI_awready = wr_addr_buffer$FULL_N && wr_prot_buffer$FULL_N ;

  // value method wr_fab_wready
  assign S_AXI_wready = wr_data_buffer$FULL_N && wr_strb_buffer$FULL_N ;

  // value method wr_fab_bvalid
  assign S_AXI_bvalid = wr_write_resp_fifo$EMPTY_N ;

  // value method wr_fab_bresp
  assign S_AXI_bresp = wr_write_resp_fifo$D_OUT ;

  // value method irq_req
  assign irq_req = 3'h2 ;

  // submodule rd_req_fifo
  FIFO2 #(.width(32'd19), .guarded(32'd1)) rd_req_fifo(.RST(RST_N),
						       .CLK(CLK),
						       .D_IN(rd_req_fifo$D_IN),
						       .ENQ(rd_req_fifo$ENQ),
						       .DEQ(rd_req_fifo$DEQ),
						       .CLR(rd_req_fifo$CLR),
						       .D_OUT(),
						       .FULL_N(rd_req_fifo$FULL_N),
						       .EMPTY_N(rd_req_fifo$EMPTY_N));

  // submodule rd_resp_fifo
  FIFO2 #(.width(32'd26), .guarded(32'd1)) rd_resp_fifo(.RST(RST_N),
							.CLK(CLK),
							.D_IN(rd_resp_fifo$D_IN),
							.ENQ(rd_resp_fifo$ENQ),
							.DEQ(rd_resp_fifo$DEQ),
							.CLR(rd_resp_fifo$CLR),
							.D_OUT(rd_resp_fifo$D_OUT),
							.FULL_N(rd_resp_fifo$FULL_N),
							.EMPTY_N(rd_resp_fifo$EMPTY_N));

  // submodule wr_addr_buffer
  FIFO2 #(.width(32'd16), .guarded(32'd1)) wr_addr_buffer(.RST(RST_N),
							  .CLK(CLK),
							  .D_IN(wr_addr_buffer$D_IN),
							  .ENQ(wr_addr_buffer$ENQ),
							  .DEQ(wr_addr_buffer$DEQ),
							  .CLR(wr_addr_buffer$CLR),
							  .D_OUT(wr_addr_buffer$D_OUT),
							  .FULL_N(wr_addr_buffer$FULL_N),
							  .EMPTY_N(wr_addr_buffer$EMPTY_N));

  // submodule wr_data_buffer
  FIFO2 #(.width(32'd24), .guarded(32'd1)) wr_data_buffer(.RST(RST_N),
							  .CLK(CLK),
							  .D_IN(wr_data_buffer$D_IN),
							  .ENQ(wr_data_buffer$ENQ),
							  .DEQ(wr_data_buffer$DEQ),
							  .CLR(wr_data_buffer$CLR),
							  .D_OUT(wr_data_buffer$D_OUT),
							  .FULL_N(wr_data_buffer$FULL_N),
							  .EMPTY_N(wr_data_buffer$EMPTY_N));

  // submodule wr_prot_buffer
  FIFO2 #(.width(32'd3), .guarded(32'd1)) wr_prot_buffer(.RST(RST_N),
							 .CLK(CLK),
							 .D_IN(wr_prot_buffer$D_IN),
							 .ENQ(wr_prot_buffer$ENQ),
							 .DEQ(wr_prot_buffer$DEQ),
							 .CLR(wr_prot_buffer$CLR),
							 .D_OUT(wr_prot_buffer$D_OUT),
							 .FULL_N(wr_prot_buffer$FULL_N),
							 .EMPTY_N(wr_prot_buffer$EMPTY_N));

  // submodule wr_strb_buffer
  FIFO2 #(.width(32'd3), .guarded(32'd1)) wr_strb_buffer(.RST(RST_N),
							 .CLK(CLK),
							 .D_IN(wr_strb_buffer$D_IN),
							 .ENQ(wr_strb_buffer$ENQ),
							 .DEQ(wr_strb_buffer$DEQ),
							 .CLR(wr_strb_buffer$CLR),
							 .D_OUT(wr_strb_buffer$D_OUT),
							 .FULL_N(wr_strb_buffer$FULL_N),
							 .EMPTY_N(wr_strb_buffer$EMPTY_N));

  // submodule wr_write_fifo
  FIFO2 #(.width(32'd46), .guarded(32'd1)) wr_write_fifo(.RST(RST_N),
							 .CLK(CLK),
							 .D_IN(wr_write_fifo$D_IN),
							 .ENQ(wr_write_fifo$ENQ),
							 .DEQ(wr_write_fifo$DEQ),
							 .CLR(wr_write_fifo$CLR),
							 .D_OUT(wr_write_fifo$D_OUT),
							 .FULL_N(wr_write_fifo$FULL_N),
							 .EMPTY_N(wr_write_fifo$EMPTY_N));

  // submodule wr_write_resp_fifo
  FIFO2 #(.width(32'd2), .guarded(32'd1)) wr_write_resp_fifo(.RST(RST_N),
							     .CLK(CLK),
							     .D_IN(wr_write_resp_fifo$D_IN),
							     .ENQ(wr_write_resp_fifo$ENQ),
							     .DEQ(wr_write_resp_fifo$DEQ),
							     .CLR(wr_write_resp_fifo$CLR),
							     .D_OUT(wr_write_resp_fifo$D_OUT),
							     .FULL_N(wr_write_resp_fifo$FULL_N),
							     .EMPTY_N(wr_write_resp_fifo$EMPTY_N));

  // inlined wires
  assign rd_addr_read_data$wget = { S_AXI_araddr, S_AXI_arprot } ;

  // submodule rd_req_fifo
  assign rd_req_fifo$D_IN = rd_addr_read_data$wget ;
  assign rd_req_fifo$ENQ = rd_req_fifo$FULL_N && S_AXI_arvalid ;
  assign rd_req_fifo$DEQ = rd_req_fifo$EMPTY_N && rd_resp_fifo$FULL_N ;
  assign rd_req_fifo$CLR = 1'b0 ;

  // submodule rd_resp_fifo
  assign rd_resp_fifo$D_IN = 26'd0 ;
  assign rd_resp_fifo$ENQ = rd_req_fifo$EMPTY_N && rd_resp_fifo$FULL_N ;
  assign rd_resp_fifo$DEQ = rd_resp_fifo$EMPTY_N && S_AXI_rready ;
  assign rd_resp_fifo$CLR = 1'b0 ;

  // submodule wr_addr_buffer
  assign wr_addr_buffer$D_IN = S_AXI_awaddr ;
  assign wr_addr_buffer$ENQ =
	     wr_addr_buffer$FULL_N && wr_prot_buffer$FULL_N && S_AXI_awvalid ;
  assign wr_addr_buffer$DEQ =
	     wr_write_fifo$FULL_N &&
	     wr_addr_buffer_i_notEmpty__4_AND_wr_prot_buffe_ETC___d60 ;
  assign wr_addr_buffer$CLR = 1'b0 ;

  // submodule wr_data_buffer
  assign wr_data_buffer$D_IN = S_AXI_wdata ;
  assign wr_data_buffer$ENQ =
	     wr_data_buffer$FULL_N && wr_strb_buffer$FULL_N && S_AXI_wvalid ;
  assign wr_data_buffer$DEQ =
	     wr_write_fifo$FULL_N &&
	     wr_addr_buffer_i_notEmpty__4_AND_wr_prot_buffe_ETC___d60 ;
  assign wr_data_buffer$CLR = 1'b0 ;

  // submodule wr_prot_buffer
  assign wr_prot_buffer$D_IN = S_AXI_awprot ;
  assign wr_prot_buffer$ENQ =
	     wr_addr_buffer$FULL_N && wr_prot_buffer$FULL_N && S_AXI_awvalid ;
  assign wr_prot_buffer$DEQ =
	     wr_write_fifo$FULL_N &&
	     wr_addr_buffer_i_notEmpty__4_AND_wr_prot_buffe_ETC___d60 ;
  assign wr_prot_buffer$CLR = 1'b0 ;

  // submodule wr_strb_buffer
  assign wr_strb_buffer$D_IN = S_AXI_wstrb ;
  assign wr_strb_buffer$ENQ =
	     wr_data_buffer$FULL_N && wr_strb_buffer$FULL_N && S_AXI_wvalid ;
  assign wr_strb_buffer$DEQ =
	     wr_write_fifo$FULL_N &&
	     wr_addr_buffer_i_notEmpty__4_AND_wr_prot_buffe_ETC___d60 ;
  assign wr_strb_buffer$CLR = 1'b0 ;

  // submodule wr_write_fifo
  assign wr_write_fifo$D_IN =
	     { wr_addr_buffer$D_OUT,
	       wr_prot_buffer$D_OUT,
	       wr_data_buffer$D_OUT,
	       wr_strb_buffer$D_OUT } ;
  assign wr_write_fifo$ENQ =
	     wr_write_fifo$FULL_N &&
	     wr_addr_buffer_i_notEmpty__4_AND_wr_prot_buffe_ETC___d60 ;
  assign wr_write_fifo$DEQ =
	     wr_write_fifo$EMPTY_N && wr_write_resp_fifo$FULL_N ;
  assign wr_write_fifo$CLR = 1'b0 ;

  // submodule wr_write_resp_fifo
  assign wr_write_resp_fifo$D_IN = 2'd0 ;
  assign wr_write_resp_fifo$ENQ =
	     wr_write_fifo$EMPTY_N && wr_write_resp_fifo$FULL_N ;
  assign wr_write_resp_fifo$DEQ = wr_write_resp_fifo$EMPTY_N && S_AXI_bready ;
  assign wr_write_resp_fifo$CLR = 1'b0 ;

  // remaining internal signals
  assign addr__h2155 = { 8'd0, wr_write_fifo$D_OUT[37:30] } ;
  assign wr_addr_buffer_i_notEmpty__4_AND_wr_prot_buffe_ETC___d60 =
	     wr_addr_buffer$EMPTY_N && wr_prot_buffer$EMPTY_N &&
	     wr_data_buffer$EMPTY_N &&
	     wr_strb_buffer$EMPTY_N ;

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (wr_write_fifo$EMPTY_N && wr_write_resp_fifo$FULL_N)
	$display("SET REGISTER: %d = %d",
		 addr__h2155,
		 wr_write_fifo$D_OUT[26:3]);
  end
  // synopsys translate_on
endmodule  // mkAWSInterruptCtrl

